这篇文章好好看看：https://juejin.im/post/5e76bd516fb9a07cce750746#heading-11

## 请求的方式
常用的`get`、`post`:
`get`:
* 获取资源（向后端请求资源）；
* get请求资源的内容会在url中显示（更不安全），即URI（统一资源定位符）部分，（客户端使用get方式向服务端请求资源，需要通过URI部分告诉服务端你需要的资源，服务端才好在解析出域名对应的服务器ip后将对应的资源返回）；
* 主要用于从服务器获得（取回）数据；（注释：GET 方法可能返回缓存数据。）

Get特点：
  ● GET 请求可被缓存
  ● GET 请求保留在浏览器历史记录中
  ● GET 请求可被收藏为书签
  ● GET 请求不应在处理敏感数据时使用
  ● GET 请求有长度限制
  ● GET 请求只应当用于取回数据
  ● 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！
  ● 数据在URL中对所有人可见

`post`: 
* 传输实体主体body（向后端提交数据）；
* 不会在URL中显示传递的内容，更安全；
* 向指定的资源提交要处理的数据；
* post也可以从服务器获取数据（不过，POST 方法不会缓存数据，并且常用于连同请求一起发送数据。）

Post特点：
  ● POST 请求不会被缓存
  ● POST 请求不会保留在浏览器历史记录中
  ● POST 不能被收藏为书签
  ● POST 请求对数据长度没有要求
  ● POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。
  ● 发送请求时，请求数据不显示在URL中，而是放在请求的body体里，formData。

其它还有：`put`、`delete`等
`put`: 传输文件，put方法自身不带验证机制，任何人都可以上传文件，不安全

## 常用的请求头有哪些？
`Host`：请求资源所在的服务器。`http1.1`新增的header头字段
`Origin`：哪个站点发送的请求，即请求发送的服务器。
`Content-type`：用于指定实体内容的媒体类型。值：`application/json`、`application/x-www-form-urlencoded`、`multipart/json`、`text/html`、`text\xml`、`text\plain`
`Content-Length(-Language、-Range、-Encoding)`：内容的长度、语言、范围大小、编码方式等
`Cookie`：使用Cookie进行状态管理（由服务器端生成Cookie信息），值：格式如：`name=value; age=value;`
<font color="red">为什么要使用cookie?</font> 
HTTP协议是无状态的，http协议自身不对请求和响应之间的通信状态进行保存（当有新的请求发送时，就会有对应的新响应产生，不会保留之前的一切请求或响应的报文的信息）
（1）请求报文（没有Cookie信息的状态）
（2）响应报文（服务器端生成Cookie信息）
（3）请求报文（自动发送保存着的Cookie信息

`Set-Cookie`: 设置Cookie。
`Cache-Control`：控制缓存行为。值：`public`、`private`、`no-cache`、`no-store`
`Referer`：当前请求页面的来源页面地址，即当前页面的上个页面地址
`Keep-Alive`：允许消息发送者暗示连接状态，可用来设置超时时长和最大请求数
`Connection`：连接管理，`http1.1`中默认是长连接。值：`keep-alive`：保持长连接、`close`：关闭长连接。request和response中都可以配置该http的header头字段。
`Accept(-Charset、-Encoding、-Language)`：用户代理可处理的媒体类型（字符集、内容编码、语言）

## HTTP状态码
状态码类别：
```
1XX：信息性状态码（接收的请求正在处理） 
100：目前为止一切正常，客户端可以继续请求
101：正在进行协议切换
103：

2XX：成功（请求正常处理完毕）  
200：OK（请求成功）
202：接收到了请求，但是尚未进行处理
204：请求处理成功，但没有资源可返回（No Content）

3XX：重定向（需要进行附加操作完成请求）
301：永久性重定向。搜索引擎会根据该响应修正，请求方法和消息主体可能会发生改变。
比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回301，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。
302：临时性重定向，请求的资源被暂时的移动到了由Location 头部指定的 URL 上。浏览器会重定向到这个URL，但是搜索引擎不会对该资源的链接进行更新。
而如果只是暂时不可用，那么直接返回302即可，和301不同的是，浏览器并不会做缓存优化。
304：缓存资源没有更新时服务器端返回304(Not Modified)
308：浏览器会进行重定向，同时搜索引擎也会更新其链接。在重定向过程中，请求方法和消息主体不会发生改变。

4XX：客户端错误（服务器无法处理请求）  
400：Bad Request 请求报文中存在语法错误（需修改请求的内容再次发送请求）
403：Forbidden，对请求资源的访问被服务器拒绝了（访问权限出现了问题），客户端错误，指的是服务器端有能力处理该请求，但是拒绝授权访问。
404：Not Found，服务器上无法找到请求的资源

5XX： 服务器错误（服务器处理请求出错）
500：Internet Server Error 网络服务错误（服务器端执行请求时发生了错误，可能是Web应用存在bug或某些临时故障）
502：Bad Gateway 网关错误
503：Service Unavailable（服务器不可用，服务器可能处于超负荷或正在进行停机维护），服务器尚未处于可以接受请求的状态。
504：Gateway Timeout 网关或者代理的服务器无法在规定的时间内获得想要的响应。
```
### 301和302
#### 1）301和302的区别。
* 301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的`Location`首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。
* 他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；
* 302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO 302好于301
 
#### 2）重定向原因：
（1）网站调整（如改变网页目录结构）；
（2）网页被移到一个新地址；
（3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。
        这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。
 
#### 3）什么时候进行301或者302跳转呢？
当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。
#### 使用301跳转的场景：
1、域名到期不想续费（或者发现了更适合网站的域名），想换个域名。
2、在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。
3、空间服务器不稳定，换空间的时候。


## http和https
`http`: 发送的都是`明文的数据`，默认端口是`80`
`https`：发送的都是`加密的数据`，把http的数据包加密了，默认端口是`443`
扩展：`ftp` 默认端口是`21`

### https证书：
<font color="red">对称加密</font>：加密钥匙和解密钥匙是同一个
<font color="red">非对称加密</font>：加密钥匙和解密钥匙是两个：`公钥`（对外公开，所有人都能拿到）；`私钥`（企业主持有，不外泄、不公开）。<font color="green">用公钥加密的数据只有私钥能解。</font>

<font color="red">https过程</font>：证书——>企业的身份证，比如百度的证书，百度的身份证
<font color="red">https证书签发机构</font>：相当于警察局申请身份证

<font color="red">客户端收到证书之后的过程：</font>
（1）下载证书，验证证书真伪（可以去证书签发机构查询）；
（2）用公钥加密随机字符串信息，只有私钥能解，发请求给服务端；
（3）服务端用私钥解出来，然后返回给客户端一个用私钥加密的字串，告诉客户端转成对称加密，加密的秘钥是xxx，这个加密秘钥只有这两个客户端和服务端之间知道，<font color="green">由非对称加密转成对称加密。</font>
<font color="red">非对称加密算法用于在握手过程中获取对称加密的秘钥，对称加密算法用于对真正传输的数据进行加密。</font>

### http传输协议：http1.0、http1.1、http2.0、http3.0
`http1.0`：每次发包都需要重新握手和挥手。
**缺点：** 连接无法复用，导致每次请求都需要经历三次握手；
`http1.1`：http请求头增加了`keep-alive`：保持连接(持续连接)。只要我们建立连接，那么在当前这个连接内只需要一次握手和一次撒手。即支持持久连接。
`http1.1`：请求数据包的发送是串行。
`http1.1`中默认是长连接。可以通过配置header头中的`Connection`字段来实现长连接和短连接：`keep-alive`：保持长连接、`close`：关闭长连接。request和response中都可以配置该http的header头字段。
**缺点**：只能一次一次来，没有什么优先策略，只能排队，非常公平，长请求（大请求）和短请求（小请求）都一样公平排队，效率低。页面整体出来，但是白页到整个页面出来的时间很长。
`http2.0`：多个请求可以同时在一个连接上并行执行，当某个请求任务耗时严重时，不会影响到其它连接的正常执行；同等条件下，小请求有抢资源的机会，不会一直排队被阻塞。页面一点一点加载出来。
`http2.0`：可以同时多个请求并行发送或响应。
`http3.0`：tcp（重试是客户端重试） ——> udp(解决不可靠是通过不断重试)	

![](http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQriba5ygCTOOjIQH4wvoJS2iaFBseyEAUfvpJQThHmTjuGuaSspUo8xppiaA/0?wx_fmt=png)

参考：
https://www.cnblogs.com/heluan/p/8620312.html
https://www.jianshu.com/p/52d86558ca57